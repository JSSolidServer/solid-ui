{"version":3,"file":"autocompleteField.js","names":["autocompleteField","dom","container","already","subject","form","doc","callbackFunction","addOneIdAndRefresh","result","name","Error","oldValue","kb","the","property","oldName","any","labelProperty","equals","sameTerm","deletables","statementsMatching","concat","insertables","st","updater","updateMany","box","appendChild","widgets","errorMessageBlock","deleteOne","_result","_name","e2","termType","store","formDoc","createElement","lhs","setAttribute","style","formFieldNameBoxStyle","rhs","ns","ui","schema","dataSource","queryParams","label","anyJS","logo","targetClass","objectURIBase","undefined","endpoint","searchByNameQuery","insitituteDetailsQuery","searchByNameURI","suppressEmptyUneditable","editable","uri","autocompleteOptions","permanent","size","obj","currentObject","currentName","display","fieldLabel","barOptions","dbLookup","renderAutocompleteControl","then","control","err"],"sources":["../../../../src/widgets/forms/autocomplete/autocompleteField.ts"],"sourcesContent":["/* Form field for doing autocompleete\n */\nimport * as ns from '../../../ns'\nimport { store } from 'solid-logic'\nimport * as widgets from '../../../widgets'\nimport * as style from '../../../style'\nimport { renderAutocompleteControl } from './autocompleteBar'\nimport { QueryParameters } from './publicData'\nimport { NamedNode, BlankNode, Literal, Variable, st } from 'rdflib'\nimport { AutocompleteOptions } from './autocompletePicker'\n/**\n  * Render a autocomplete form field\n  *\n  * The autocomplete form searches for an object in a definitive public database,\n  * and allows the user to search for it by name, displaying a list of objects whose names match\n  * the input to date, and letting  the user either click on one of the list,\n  * or just go on untill there is only one.  The process then returns two values,\n  * the URiI of the object and its name.\n  *\n  * @param dom The HTML Document object aka Document Object Model\n  * @param container  If present, the created widget will be appended to this\n  * @param already A hash table of (form, subject) kept to prevent recursive forms looping\n  * @param subject The thing about which the form displays/edits data\n  * @param form The form or field to be rendered\n  * @param doc The web document in which the data is\n  * @param callbackFunction Called when data is changed so other parts can be refreshed.\n  *\n  * Form properties:\n  * @param ui:property  The property to store the object itself\n  * @param ui:labelProperty The property used to store the name of the object\n  * @param ui:category The class of objects to be searched, if fixed (else dep on class of subject)\n  *\n  * @returns The HTML widget created\n */\n// eslint-disable-next-line complexity\nexport function autocompleteField (\n  dom: HTMLDocument,\n  container: HTMLElement | undefined,\n  already,\n  subject: NamedNode | BlankNode | Variable,\n  form: NamedNode,\n  doc: NamedNode | undefined,\n  callbackFunction: (_ok: boolean, _errorMessage: string) => void\n): HTMLElement {\n  async function addOneIdAndRefresh (result:NamedNode | Literal, name: Literal) {\n    if (!name) {\n      throw new Error('autocompleteField:  No name set.')\n    }\n    const oldValue = kb.the(subject, property as any, null, doc)\n    if (oldValue) {\n      const oldName = kb.any(oldValue as any, labelProperty as any, null, doc)\n      if (oldValue.equals(result) && oldName && oldName.sameTerm(name)) {\n        // console.log('No change: same values.')\n        return\n      }\n    }\n    const deletables = oldValue\n      ? kb.statementsMatching(subject, property as any, oldValue, doc)\n        .concat(kb.statementsMatching(oldValue as any, labelProperty as any, null, doc))\n      : []\n    // console.log('autocompleteField Deletables ' + deletables.map(st => st.toNT()))\n    const insertables = [st(subject, property as any, result, doc),\n      st(result as any, labelProperty as any, name, doc)] // @@ track the language of the  name too!\n    // console.log(`AC form: ${deletables.length} to delete and ${insertables.length} to insert`)\n    try {\n      // console.log('@@@ AC updating ', deletables, insertables)\n      await kb.updater?.updateMany(deletables, insertables)\n    } catch (err) {\n      callbackFunction(false, err)\n      box.appendChild(widgets.errorMessageBlock(dom, 'Autocomplete form data update error:' + err, null, err))\n      return\n    }\n    callbackFunction(true, '')\n  }\n\n  async function deleteOne (_result:NamedNode | Literal, _name: Literal) {\n    const oldValue = kb.the(subject, property as any, null, doc)\n    if (!oldValue) {\n      callbackFunction(false, 'NO data to elete')\n      box.appendChild(widgets.errorMessageBlock(dom, 'Autocomplete delete: no old data!'))\n      return\n    }\n    // const oldName = kb.any(oldValue as any, labelProperty as any, null, doc)\n    const deletables = kb.statementsMatching(subject, property as any, oldValue, doc)\n      .concat(kb.statementsMatching(oldValue as any, labelProperty as any, null, doc))\n    // console.log('autocompleteField Deletables ' + deletables.map(st => st.toNT()))\n    const insertables = []\n    // console.log(`AC form delete: ${deletables.length} to delete and ${insertables.length} to insert`)\n    try {\n      // console.log('@@@ AC updating ', deletables, insertables)\n      await kb.updater?.updateMany(deletables, insertables)\n    } catch (err) {\n      const e2 = new Error('Autocomplete form data delete error:' + err)\n      callbackFunction(false, err)\n      box.appendChild(widgets.errorMessageBlock(dom, e2, null, err))\n      return\n    }\n    callbackFunction(true, '') // changed\n  }\n\n  if (subject.termType !== 'NamedNode') {\n    throw new Error('Sorry this field only works on NamedNode subjects (for editable)')\n  }\n  const kb = store\n  const formDoc = form.doc ? form.doc() : null // @@ if blank no way to know\n\n  const box = dom.createElement('div')\n  if (container) container.appendChild(box)\n  const lhs = dom.createElement('div')\n  lhs.setAttribute('class', 'formFieldName')\n  lhs.setAttribute('style', style.formFieldNameBoxStyle)\n  box.appendChild(lhs)\n  const rhs = dom.createElement('div')\n  rhs.setAttribute('class', 'formFieldValue')\n  box.appendChild(rhs)\n\n  const property = kb.any(form, ns.ui('property'))\n  if (!property) {\n    return box.appendChild(\n      widgets.errorMessageBlock(dom, 'Error: No property given for autocomplete field: ' + form)\n    )\n  }\n  const labelProperty = kb.any(form, ns.ui('labelProperty')) || ns.schema('name')\n\n  // Parse the data source into query options\n\n  const dataSource = kb.any(form, ns.ui('dataSource')) as NamedNode | undefined\n  if (!dataSource) {\n    // console.log('@@ connectedStatements ACF ', kb.connectedStatements(form).map(x => x.toNT()).join('\\n'))\n    return box.appendChild(\n      widgets.errorMessageBlock(dom, 'Error: No data source given for autocomplete field: ' + form)\n    )\n  }\n  const queryParams:QueryParameters = {\n    // targetClass: kb.any(dataSource, ns.ui('targetClass'), null, dataSource.doc()) as NamedNode | undefined,\n    label: kb.anyJS(dataSource, ns.schema('name'), null, dataSource.doc()),\n    logo: (kb.any(dataSource, ns.schema('logo'), null, dataSource.doc())) as NamedNode | undefined\n  }\n\n  // @@ Should we pass the target class in from the data source definition or use a current type of the subject\n  const targetClass = (kb.any(form, ns.ui('targetClass'), null, form.doc()) || // class in form takes pecedence\n      kb.any(dataSource, ns.ui('targetClass'), null, dataSource.doc())) as NamedNode | undefined\n  if (targetClass) {\n    queryParams.targetClass = targetClass\n  }\n\n  queryParams.objectURIBase = (kb.any(dataSource, ns.ui('objectURIBase'), null, dataSource.doc()) || undefined) as NamedNode | undefined\n\n  /*\n  if (!queryParams.targetClass) {\n    const klass = kb.any(subject, ns.rdf('type')) as NamedNode | undefined\n    // @@ be more selective of which class if many\n    // @@ todo: Take ALL classes,  and compare them with those the data source knows about\n    // with translation where necessary.  Find most specific of the classes for the search.\n    if (!klass) throw new Error('Autocomplete: No class specified or is current type of' + subject)\n    queryParams.targetClass = klass\n  }\n  */\n  const endpoint = kb.anyJS(dataSource, ns.ui('endpoint'), null, dataSource.doc()) as string | undefined\n  if (endpoint) { // SPARQL\n    queryParams.endpoint = endpoint\n\n    queryParams.searchByNameQuery = kb.anyJS(dataSource, ns.ui('searchByNameQuery'), null, dataSource.doc())\n    if (!queryParams.searchByNameQuery) {\n      return box.appendChild(\n        widgets.errorMessageBlock(dom, 'Error: No searchByNameQuery given for endpoint data Source: ' + form))\n    }\n    queryParams.insitituteDetailsQuery = kb.anyJS(dataSource, ns.ui('insitituteDetailsQuery'), null, dataSource.doc())\n  } else {\n    // return box.appendChild(\n    //  widgets.errorMessageBlock(dom, 'Error: No SPARQL endpoint given for autocomplete field: ' + form))\n    const searchByNameURI = kb.anyJS(dataSource, ns.ui('searchByNameURI'))\n    if (!searchByNameURI) {\n      return box.appendChild(\n        widgets.errorMessageBlock(dom, 'Error: No searchByNameURI OR sparql endpoint given for dataSource: ' + dataSource)\n      )\n    }\n    queryParams.searchByNameURI = searchByNameURI\n  }\n  // It can be cleaner to just remove empty fields if you can't edit them anyway\n  const suppressEmptyUneditable = kb.anyJS(form, ns.ui('suppressEmptyUneditable'), null, formDoc)\n  const editable = kb.updater?.editable((doc as NamedNode).uri)\n\n  const autocompleteOptions:AutocompleteOptions = { // cancelButton?: HTMLElement,\n    permanent: true,\n    targetClass: queryParams.targetClass, // @@ simplify?\n    queryParams\n  }\n\n  autocompleteOptions.size = kb.anyJS(form, ns.ui('size'), null, formDoc) || undefined\n\n  let obj = kb.any(subject, property as any, undefined, doc)\n  if (!obj) {\n    obj = kb.any(form, ns.ui('default'))\n    if (obj) {\n      autocompleteOptions.currentObject = obj as NamedNode\n      autocompleteOptions.currentName = kb.any(autocompleteOptions.currentObject, labelProperty, null, doc) as Literal\n    } else { // No data or default. Should we suprress the whole field?\n      if (suppressEmptyUneditable && !editable) {\n        box.style.display = 'none' // clutter removal\n        return box\n      }\n    }\n  } else { // get object and name from target data:\n    autocompleteOptions.currentObject = obj as NamedNode\n    autocompleteOptions.currentName = kb.any(autocompleteOptions.currentObject, labelProperty, null, doc) as Literal\n  }\n\n  lhs.appendChild(widgets.fieldLabel(dom, property as any, form))\n\n  const barOptions = {\n    editable,\n    dbLookup: true\n  }\n\n  renderAutocompleteControl(dom, subject as NamedNode, barOptions, autocompleteOptions, addOneIdAndRefresh, deleteOne).then((control) => {\n    rhs.appendChild(control)\n  }, (err) => {\n    rhs.appendChild(widgets.errorMessageBlock(dom, `Error rendering autocomplete ${form}: ${err}`, '#fee', err)) //\n  })\n  return box\n}\n\n// ends\n"],"mappings":"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"}